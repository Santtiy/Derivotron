[1mdiff --git a/src/components/LimitsExplorer.tsx b/src/components/LimitsExplorer.tsx[m
[1mnew file mode 100644[m
[1mindex 0000000..5725407[m
[1m--- /dev/null[m
[1m+++ b/src/components/LimitsExplorer.tsx[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32mimport React, { useMemo } from "react";[m
[32m+[m[32mimport { tols } from "./tols";[m
[32m+[m
[32m+[m[32m// Tipos (ajusta si ya existen en otro archivo)[m
[32m+[m[32mtype VerdictStatus = "exists" | "diverges" | "inconclusive";[m
[32m+[m[32mtype Verdict = { status: VerdictStatus; value: number | null; spread: number };[m
[32m+[m[32mtype LimitPath = { label: string; points: { x: number; y: number }[]; status?: "converge" | "diverge" | "unknown" };[m
[32m+[m
[32m+[m[32mconst result = useMemo((): { verdict: Verdict; paths: LimitPath[] } => {[m
[32m+[m[32m  if (!compiled) {[m
[32m+[m[32m    return { verdict: { status: "inconclusive", value: null, spread: Number.NaN }, paths: [] };[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // ...existing code...[m
[32m+[m[32m  // calcula conv, spreadAll, paths, etc.[m
[32m+[m
[32m+[m[32m  const verdict: Verdict =[m
[32m+[m[32m    spreadAll < tols.epsilon[m
[32m+[m[32m      ? { status: "exists", value: conv[0], spread: spreadAll }[m
[32m+[m[32m      : { status: "inconclusive", value: conv[0], spread: spreadAll };[m
[32m+[m
[32m+[m[32m  return { verdict, paths };[m
[32m+[m[32m}, [compiled, x0, y0, routes, tols]);[m
[32m+[m
[32m+[m[32mexport default result;[m
\ No newline at end of file[m
[1mdiff --git a/src/components/derivatives-calculator.tsx b/src/components/derivatives-calculator.tsx[m
[1mindex 2fe0711..e9324dc 100644[m
[1m--- a/src/components/derivatives-calculator.tsx[m
[1m+++ b/src/components/derivatives-calculator.tsx[m
[36m@@ -13,29 +13,35 @@[m [mimport { trySymbolicDerivatives, tangentPlaneAt } from "../lib/symbolic";[m
 const math = create(all);[m
 [m
 interface Props {[m
[31m-  functionExpr?: string;[m
[32m+[m[32m  functionExpr: string;[m
   onPointChange?: (p: { x: number; y: number } | null) => void;[m
 }[m
 [m
[31m-export default function DerivativesCalculator({[m
[31m-  functionExpr,[m
[31m-  onPointChange, // NUEVO[m
[31m-}: { functionExpr: string; onPointChange?: (p:{x:number;y:number}|null)=>void }) {[m
[31m-  const [x0,setX0] = useState(0);[m
[31m-  const [y0,setY0] = useState(0);[m
[31m-  const [expr, setExpr] = useState<string>(functionExpr);[m
[31m-  const [rawPoint, setRawPoint] = useState<string>(`${x0},${y0}`);[m
[31m-  const [point, setPoint] = useState<{ x: number; y: number }>({ x:x0, y:y0 });[m
[32m+[m[32mexport default function DerivativesCalculator({ functionExpr, onPointChange }: Props) {[m
[32m+[m[32m  const [expr, setExpr] = useState<string>(functionExpr ?? "");[m
[32m+[m[32m  const [rawPoint, setRawPoint] = useState<string>("0,0");[m
[32m+[m[32m  const [point, setPoint] = useState<{ x: number; y: number }>({ x: 0, y: 0 });[m
   const [showAdvanced, setShowAdvanced] = useState(false);[m
   const [forceRecalc, setForceRecalc] = useState(0);[m
 [m
[31m-  // Parse punto "a,b"[m
[31m-  useMemo(() => {[m
[32m+[m[32m  // Mantener expr sincronizada con la funciÃ³n global[m
[32m+[m[32m  useEffect(() => {[m
[32m+[m[32m    setExpr(functionExpr ?? "");[m
[32m+[m[32m  }, [functionExpr]);[m
[32m+[m
[32m+[m[32m  // Parsear â€œx,yâ€ a objeto punto y emitir al 3D[m
[32m+[m[32m  useEffect(() => {[m
     const parts = rawPoint.split(/[,;\s]+/).filter(Boolean);[m
[31m-    const x = parseFloat(parts[0]);[m
[31m-    const y = parseFloat(parts[1]);[m
[31m-    if (Number.isFinite(x) && Number.isFinite(y)) setPoint({ x, y });[m
[31m-  }, [rawPoint]);[m
[32m+[m[32m    const x = Number(parts[0]);[m
[32m+[m[32m    const y = Number(parts[1]);[m
[32m+[m[32m    if (Number.isFinite(x) && Number.isFinite(y)) {[m
[32m+[m[32m      const p = { x, y };[m
[32m+[m[32m      setPoint(p);[m
[32m+[m[32m      onPointChange?.(p);[m
[32m+[m[32m    } else {[m
[32m+[m[32m      onPointChange?.(null);[m
[32m+[m[32m    }[m
[32m+[m[32m  }, [rawPoint, onPointChange]);[m
 [m
   const compiled = useMemo(() => {[m
     try {[m
[36m@@ -86,11 +92,9 @@[m [mexport default function DerivativesCalculator({[m
     setForceRecalc((c) => c + 1);[m
   };[m
 [m
[31m-  useEffect(()=>{ onPointChange?.({x:x0,y:y0}); },[x0,y0, onPointChange]); // emite cambios[m
[31m-[m
   const handleRecalc = () => {[m
     setForceRecalc((c) => c + 1);[m
[31m-    onPointChange?.({ x: x0, y: y0 });[m
[32m+[m[32m    onPointChange?.(point); // vuelve a emitir el punto actual[m
   };[m
 [m
   return ([m
[36m@@ -114,59 +118,35 @@[m [mexport default function DerivativesCalculator({[m
             )}[m
           </div>[m
 [m
[31m-            <div>[m
[31m-              <Label>Punto (x0,y0)</Label>[m
[31m-              <Input[m
[31m-                value={rawPoint}[m
[31m-                onChange={(e) => setRawPoint(e.target.value)}[m
[31m-                placeholder="Ej: 1,2"[m
[31m-              />[m
[31m-            </div>[m
[32m+[m[32m          <div>[m
[32m+[m[32m            <Label>Punto (x0,y0)</Label>[m
[32m+[m[32m            <Input[m
[32m+[m[32m              value={rawPoint}[m
[32m+[m[32m              onChange={(e) => setRawPoint(e.target.value)}[m
[32m+[m[32m              placeholder="Ej: 1,2"[m
[32m+[m[32m            />[m
[32m+[m[32m          </div>[m
 [m
           <div className="flex flex-wrap gap-2 text-xs">[m
[31m-            <Button[m
[31m-              variant="outline"[m
[31m-              onClick={() => applyPreset("x^2 + y^2")}[m
[31m-              className="h-7 px-2"[m
[31m-            >[m
[32m+[m[32m            <Button variant="outline" onClick={() => applyPreset("x^2 + y^2")} className="h-7 px-2">[m
               xÂ²+yÂ²[m
             </Button>[m
[31m-            <Button[m
[31m-              variant="outline"[m
[31m-              onClick={() => applyPreset("sin(x)*cos(y)")}[m
[31m-              className="h-7 px-2"[m
[31m-            >[m
[32m+[m[32m            <Button variant="outline" onClick={() => applyPreset("sin(x)*cos(y)")} className="h-7 px-2">[m
               sin(x)cos(y)[m
             </Button>[m
[31m-            <Button[m
[31m-              variant="outline"[m
[31m-              onClick={() => applyPreset("exp(x*y)")}[m
[31m-              className="h-7 px-2"[m
[31m-            >[m
[32m+[m[32m            <Button variant="outline" onClick={() => applyPreset("exp(x*y)")} className="h-7 px-2">[m
               {"e^{xy}"}[m
             </Button>[m
[31m-            <Button[m
[31m-              variant="outline"[m
[31m-              onClick={() => applyPreset("1/(x^2 + y^2)")}[m
[31m-              className="h-7 px-2"[m
[31m-            >[m
[32m+[m[32m            <Button variant="outline" onClick={() => applyPreset("1/(x^2 + y^2)")} className="h-7 px-2">[m
               1/(xÂ²+yÂ²)[m
             </Button>[m
           </div>[m
 [m
           <div className="flex items-center gap-2">[m
[31m-            <Button[m
[31m-              onClick={handleRecalc}[m
[31m-              disabled={hasError}[m
[31m-              className="h-8"[m
[31m-            >[m
[32m+[m[32m            <Button onClick={handleRecalc} disabled={hasError} className="h-8">[m
               Recalcular[m
             </Button>[m
[31m-            <Button[m
[31m-              variant="ghost"[m
[31m-              onClick={() => setShowAdvanced((s) => !s)}[m
[31m-              className="h-8 text-xs"[m
[31m-            >[m
[32m+[m[32m            <Button variant="ghost" onClick={() => setShowAdvanced((s) => !s)} className="h-8 text-xs">[m
               {showAdvanced ? "Ocultar avanzado" : "Mostrar avanzado"}[m
             </Button>[m
           </div>[m
[36m@@ -196,18 +176,13 @@[m [mexport default function DerivativesCalculator({[m
         </div>[m
 [m
         <div className="text-xs text-gray-400 mt-3">[m
[31m-          Punto:{" "}[m
[31m-          <span className="font-mono">[m
[31m-            ({point.x.toPrecision(3)}, {point.y.toPrecision(3)})[m
[31m-          </span>[m
[32m+[m[32m          Punto: <span className="font-mono">({point.x.toPrecision(3)}, {point.y.toPrecision(3)})</span>[m
         </div>[m
 [m
         <div className="mt-3 text-xs text-gray-400">[m
           Rango (â‰ˆ):{" "}[m
[31m-          {scan.range[m
[31m-            ? `${scan.range.min.toPrecision(4)} a ${scan.range.max.toPrecision(4)}`[m
[31m-            : "â€”"}{" "}[m
[31m-          Â· InvÃ¡lidos: {scan.invalidPoints}/{scan.total} ({invalidPct}%)[m
[32m+[m[32m          {scan.range ? `${scan.range.min.toPrecision(4)} a ${scan.range.max.toPrecision(4)}` : "â€”"} Â·[m
[32m+[m[32m          InvÃ¡lidos: {scan.invalidPoints}/{scan.total} ({invalidPct}%)[m
         </div>[m
 [m
         {showAdvanced && ([m
[36m@@ -215,21 +190,14 @@[m [mexport default function DerivativesCalculator({[m
             <div className="font-semibold text-blue-300">Avanzado</div>[m
             <div>[m
               Derivadas simbÃ³licas:{" "}[m
[31m-              {symbolic ? ([m
[31m-                <span className="font-mono">[m
[31m-                  fx={symbolic.dx} Â· fy={symbolic.dy}[m
[31m-                </span>[m
[31m-              ) : ([m
[31m-                "No disponible"[m
[31m-              )}[m
[32m+[m[32m              {symbolic ? <span className="font-mono">fx={symbolic.dx} Â· fy={symbolic.dy}</span> : "No disponible"}[m
             </div>[m
             <div>[m
               Plano tangente:{" "}[m
               {plane ? ([m
                 <span className="font-mono">[m
[31m-                  z â‰ˆ {plane.z0.toPrecision(4)} + {plane.a.toPrecision(4)}(x-[m
[31m-                  {point.x.toPrecision(3)}) + {plane.b.toPrecision(4)}(y-[m
[31m-                  {point.y.toPrecision(3)})[m
[32m+[m[32m                  z â‰ˆ {plane.z0.toPrecision(4)} + {plane.a.toPrecision(4)}(x-{point.x.toPrecision(3)}) +{" "}[m
[32m+[m[32m                  {plane.b.toPrecision(4)}(y-{point.y.toPrecision(3)})[m
                 </span>[m
               ) : ([m
                 "â€”"[m
[1mdiff --git a/src/components/integration-calculator.tsx b/src/components/integration-calculator.tsx[m
[1mindex 34c4ea5..0c95437 100644[m
[1m--- a/src/components/integration-calculator.tsx[m
[1m+++ b/src/components/integration-calculator.tsx[m
[36m@@ -22,12 +22,11 @@[m [minterface Props {[m
 }[m
 [m
 function compileSafe(expr: string) {[m
[32m+[m[32m  try {[m
     return compile(expr);[m
[31m-    try {[m
[31m-      return compile(expr);[m
[31m-    } catch {[m
[31m-      return null;[m
[31m-    }[m
[32m+[m[32m  } catch {[m
[32m+[m[32m    return null;[m
[32m+[m[32m  }[m
 }[m
 function makeEval(expr: string) {[m
   const c = compileSafe(expr);[m
[1mdiff --git a/src/components/layouts/CalculatorLayout.tsx b/src/components/layouts/CalculatorLayout.tsx[m
[1mindex 049ce69..95a097a 100644[m
[1m--- a/src/components/layouts/CalculatorLayout.tsx[m
[1m+++ b/src/components/layouts/CalculatorLayout.tsx[m
[36m@@ -76,10 +76,20 @@[m [mexport function CalculatorLayout() {[m
                   <OptimizationCalculatorWithCandidates functionExpr={functionExpr} onCandidates={setOptPoints} />[m
                 </TabsContent>[m
                 <TabsContent value="integration">[m
[31m-                  <IntegrationCalculator functionExpr={functionExpr} onRegionChange={(r)=>setRegionRect(r)} />[m
[32m+[m[32m                  <IntegrationCalculator[m
[32m+[m[32m                    functionExpr={functionExpr}[m
[32m+[m[32m                    onRegionChange={(r)=>setRegionRect(r)}[m
[32m+[m[32m                    onRegionTypeI={(cfg)=>setRegionTypeI(cfg)}[m
[32m+[m[32m                    onRegionTypeII={(cfg)=>setRegionTypeII(cfg)}[m
[32m+[m[32m                    onRegionPolar={(cfg)=>setRegionPolar(cfg)}[m
[32m+[m[32m                  />[m
                 </TabsContent>[m
                 <TabsContent value="limits">[m
[31m-                  <LimitsCalculator functionExpr={functionExpr} onPointChange={(p)=>setLimitPoint(p)} />[m
[32m+[m[32m                  <LimitsCalculator[m
[32m+[m[32m                    functionExpr={functionExpr}[m
[32m+[m[32m                    onPointChange={(p)=>setLimitPoint(p)}[m
[32m+[m[32m                    onPathsChange={(paths)=>setPathsLimits(paths)}[m
[32m+[m[32m                  />[m
                 </TabsContent>[m
               </div>[m
             </Tabs>[m
[1mdiff --git a/src/components/layouts/LimitsExplorer.tsx b/src/components/layouts/LimitsExplorer.tsx[m
[1mindex 016c1b3..8e23303 100644[m
[1m--- a/src/components/layouts/LimitsExplorer.tsx[m
[1m+++ b/src/components/layouts/LimitsExplorer.tsx[m
[36m@@ -1,9 +1,8 @@[m
 "use client";[m
 [m
[31m-import React, { useMemo, useState, useEffect } from "react";[m
[32m+[m[32mimport { useMemo, useState, useEffect } from "react";[m
 import { create, all } from "mathjs";[m
 import { Card } from "../ui/card";[m
[31m-// Controles legacy eliminados; la UI vive en RoutesAndTolerancePanel[m
 import { RoutesAndTolerancePanel } from "../limits/RoutesAndTolerancePanel";[m
 [m
 const math = create(all, { number: "number" });[m
[36m@@ -12,7 +11,9 @@[m [mtype PathSample = {[m
   label: string;[m
   points: { x: number; y: number; r: number }[];[m
   values: number[];[m
[31m-  convergesTo?: number;[m
[32m+[m[32m  candidate?: number;[m
[32m+[m[32m  spread?: number;[m
[32m+[m[32m  status?: "estable" | "inestable";[m
   error?: string;[m
 };[m
 [m
[36m@@ -20,9 +21,8 @@[m [mtype Verdict = { status: "exists" | "diverges" | "inconclusive"; value?: number;[m
 [m
 function safeCompile(expr: string) {[m
   try {[m
[31m-    // Compila una expresiÃ³n en tÃ©rminos de x,y usando mathjs[m
     return math.compile(expr);[m
[31m-  } catch (e) {[m
[32m+[m[32m  } catch {[m
     return null;[m
   }[m
 }[m
[36m@@ -53,7 +53,6 @@[m [mfunction linePaths(thetaList: number[], radii: number[], x0 = 0, y0 = 0): PathSa[m
 function parabolaPaths(radii: number[], x0 = 0, y0 = 0, ks = [-1, -0.5, 0.5, 1]) {[m
   return ks.map((k) => {[m
     const pts = radii.map((r) => {[m
[31m-      // parÃ¡bola centrada en (x0,y0) con parÃ¡metro k: y = k (x - x0)^2 + y0[m
       const x = x0 + r;[m
       const y = y0 + k * Math.pow(r, 2);[m
       return { x, y, r };[m
[36m@@ -71,36 +70,70 @@[m [mfunction analyzeConvergence(values: number[]) {[m
   return { convergesTo: avg, spread };[m
 }[m
 [m
[31m-// analyzeConvergence(values)[m
[31m-const conv = analyzeConvergence([1.02, 1.01, 1.005, 1.0008]);[m
[31m-/*[m
[31m-{ convergesTo: ~1.0056 (promedio Ãºltimos finitos), spread: ~0.019 }[m
[31m-*/[m
[32m+[m[32mfunction parseCustomAngles(text: string): number[] {[m
[32m+[m[32m  return text[m
[32m+[m[32m    .split(/[,;\s]+/)[m
[32m+[m[32m    .map((s) => s.trim())[m
[32m+[m[32m    .filter(Boolean)[m
[32m+[m[32m    .map((a) => {[m
[32m+[m[32m      const v = Number(a);[m
[32m+[m[32m      if (!Number.isFinite(v)) return null;[m
[32m+[m[32m      return Math.abs(v) > 2 * Math.PI ? (v * Math.PI) / 180 : v;[m
[32m+[m[32m    })[m
[32m+[m[32m    .filter((v): v is number => v !== null);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunction randomCurves(n: number, seed: string, radii: number[], x0: number, y0: number): PathSample[] {[m
[32m+[m[32m  let s = seed ? [...seed].reduce((a, c) => a + c.charCodeAt(0), 0) : 1234567;[m
[32m+[m[32m  const rand = () => (s = (s * 16807) % 2147483647) / 2147483647;[m
[32m+[m[32m  const curves: PathSample[] = [];[m
[32m+[m[32m  for (let i = 0; i < n; i++) {[m
[32m+[m[32m    const baseTheta = rand() * 2 * Math.PI;[m
[32m+[m[32m    const pts = radii.map((r) => {[m
[32m+[m[32m      const theta = baseTheta + (rand() - 0.5) * 0.15;[m
[32m+[m[32m      return { x: x0 + r * Math.cos(theta), y: y0 + r * Math.sin(theta), r };[m
[32m+[m[32m    });[m
[32m+[m[32m    curves.push({ label: `aleatoria ${i + 1}`, points: pts, values: [] });[m
[32m+[m[32m  }[m
[32m+[m[32m  return curves;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Reemplaza computeMixedPaths:[m
[32m+[m[32mfunction computeMixedPaths([m
[32m+[m[32m  compiled: any,[m
[32m+[m[32m  x0: number,[m
[32m+[m[32m  y0: number,[m
[32m+[m[32m  routes: { anglesN: number; customAngles: string; randomCurves: number; seed: string },[m
[32m+[m[32m  tols: { epsilon: number; delta: number; convTol: number }[m
[32m+[m[32m) {[m
[32m+[m[32m  const radii = makeRadii(6, Math.max(Math.min(tols.delta, 0.9), 0.3));[m
[32m+[m[32m  const autoAngles = Array.from({ length: routes.anglesN }, (_, i) => (2 * Math.PI * i) / routes.anglesN);[m
[32m+[m[32m  const custom = parseCustomAngles(routes.customAngles);[m
[32m+[m[32m  const thetas = custom.length ? custom : autoAngles;[m
 [m
[31m-function computeMixedPaths(compiled: any, x0: number, y0: number) {[m
[31m-  const radii = makeRadii(5, 0.6);[m
[31m-  // const thetas = [0, Math.PI / 6, Math.PI / 3, Math.PI / 2, (2 * Math.PI) / 3, Math.PI];[m
[31m-  const thetas = [0, Math.PI / 4];[m
   const paths: PathSample[] = [[m
     ...linePaths(thetas, radii, x0, y0),[m
[31m-    // parabolaPaths(radii, x0, y0, [-1, -0.5, 0.5, 1]),[m
[31m-    // solo k=-1 y k=1[m
[31m-    ...parabolaPaths(radii, 0, 0, [-1, 1]),[m
[32m+[m[32m    ...parabolaPaths(radii, x0, y0, [-1, 1]),[m
[32m+[m[32m    ...randomCurves(routes.randomCurves, routes.seed, radii, x0, y0),[m
   ];[m
 [m
   for (const p of paths) {[m
[31m-    p.values = p.points.map((pt) => evalAt(compiled, pt.x, pt.y));[m
[32m+[m[32m    p.values = p.points.map(pt => evalAt(compiled, pt.x, pt.y));[m
     const { convergesTo, spread } = analyzeConvergence(p.values);[m
[31m-    p.convergesTo = convergesTo;[m
[31m-    if (!Number.isFinite(convergesTo)) p.error = "no finito";[m
[32m+[m[32m    if (Number.isFinite(convergesTo)) {[m
[32m+[m[32m      p.candidate = convergesTo;[m
[32m+[m[32m      p.spread = spread;[m
[32m+[m[32m      p.status = spread < tols.convTol ? "estable" : "inestable";[m
[32m+[m[32m    } else {[m
[32m+[m[32m      p.error = "sin datos";[m
[32m+[m[32m      p.status = "inestable";[m
[32m+[m[32m    }[m
   }[m
[31m-[m
   return paths;[m
 }[m
 [m
[31m-/* PequeÃ±o componente local que muestra un veredicto simple.[m
[31m-   Si ya existe VerdictView en tu proyecto, reemplaza esto por la importaciÃ³n. */[m
[31m-function VerdictView({ verdict, tol }: { verdict: Verdict; tol?: number }) {[m
[32m+[m[32m/* Veredicto simple */[m
[32m+[m[32mfunction VerdictView({ verdict }: { verdict: Verdict }) {[m
   if (!verdict) return null;[m
   const color =[m
     verdict.status === "exists" ? "text-emerald-400" : verdict.status === "diverges" ? "text-rose-400" : "text-yellow-400";[m
[36m@@ -120,25 +153,44 @@[m [mfunction VerdictView({ verdict, tol }: { verdict: Verdict; tol?: number }) {[m
   );[m
 }[m
 [m
[31m-/* Componente auxiliar: panel separado para "Resultado (rutas mixtas)" */[m
[31m-function MixedRoutesResults({ compiled, x0, y0 }: { compiled: any; x0: number; y0: number }) {[m
[31m-  const result = useMemo(() => {[m
[31m-    if (!compiled) {[m
[31m-      return { verdict: { status: "inconclusive" } as Verdict, paths: [] as PathSample[] };[m
[31m-    }[m
[31m-    const paths = computeMixedPaths(compiled, x0, y0);[m
[31m-    // calculo sencillo del veredicto global[m
[31m-    const convValues = paths.map((p) => p.convergesTo).filter(Number.isFinite) as number[];[m
[31m-    const spreadAll = convValues.length ? Math.max(...convValues) - Math.min(...convValues) : Infinity;[m
[31m-    const verdict: Verdict = spreadAll < 1e-3 ? { status: "exists", value: convValues[0], spread: spreadAll } : { status: "inconclusive" };[m
[32m+[m[32mfunction MixedRoutesResults({[m
[32m+[m[32m  compiled,[m
[32m+[m[32m  x0,[m
[32m+[m[32m  y0,[m
[32m+[m[32m  routes,[m
[32m+[